/*
 *      Copyright (C) 2014 Team XBMC
 *      http://xbmc.org
 *
 *  This Program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2, or (at your option)
 *  any later version.
 *
 *  This Program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with XBMC; see the file COPYING.  If not, see
 *  <http://www.gnu.org/licenses/>.
 *
 */
#ifndef __PERIPHERAL_DLL_H__
#define __PERIPHERAL_DLL_H__

#include "xbmc_peripheral_types.h"

#define PERIPHERAL_ADDON_JOYSTICKS // TODO

#ifdef __cplusplus
extern "C"
{
#endif

  /// @name Peripheral operations
  ///{
  /*!
   * @brief  Get the PERIPHERAL_API_VERSION used to compile this peripheral add-on
   * @return XBMC_PERIPHERAL_API_VERSION from xbmc_peripheral_types
   * @remarks Valid implementation required
   *
   * Used to check if the implementation is compatible with the frontend.
   */
  const char* GetPeripheralAPIVersion(void);

  /*!
   * @brief Get the XBMC_PERIPHERAL_MIN_API_VERSION used to compile this peripheral add-on
   * @return XBMC_PERIPHERAL_MIN_API_VERSION from xbmc_peripheral_types
   * @remarks Valid implementation required
   *
   * Used to check if the implementation is compatible with the frontend.
   */
  const char* GetMinimumPeripheralAPIVersion(void);

  /*!
   * @brief Get the list of features that this add-on provides
   * @param pCapabilities The add-on's capabilities.
   * @return PERIPHERAL_NO_ERROR if the properties were fetched successfully.
   * @remarks Valid implementation required.
   *
   * Called by the frontend to query the add-on's capabilities and supported
   * peripherals. All capabilities that the add-on supports should be set to true.
   *
   */
  PERIPHERAL_ERROR GetAddonCapabilities(PERIPHERAL_CAPABILITIES *pCapabilities);

  /*!
   * @brief Perform a scan for joysticks
   * @return PERIPHERAL_NO_ERROR if successful; joysticks must be freed using
   * FreeJoysticks() in this case
   *
   * The frontend calls this when a hardware change is detected. If an add-on
   * detects a hardware change, it can trigger this function using the
   * TriggerScan() callback.
   */
  PERIPHERAL_ERROR PerformDeviceScan(unsigned int* peripheral_count, PERIPHERAL_SCAN_RESULT** scan_results);
  void FreeScanResults(unsigned int peripheral_count, PERIPHERAL_SCAN_RESULT* scan_results);
  ///}

  /// @name Joystick operations
  /*!
   * Joystick drivers report events for three virtual elements:
   *
   *    * button:  Element with state pressed/unpressed
   *
   *    * hat:     Directional pad, opposing buttons are mutually exclusive
   *               yielding 9 states (cardinal/intercardinal directions and
   *               unpressed)
   *
   *    * axis:    Element with continuous state from -1.0 to 1.0, inclusive
   *
   * Joystick peripherals translate these virtual elements into two physical
   * mechanisms:
   *
   *    * button:       Can be digital (state pressed/unpressed) or analog
   *                    (e.g. pressure-sensitive button or trigger with travel
   *                    distance from 0.0 to 1.0, inclusive)
   *
   *    * analog stick: Can travel in two orthogonal directions (horizontal
   *                    displacement and vertical displacement from -1.0 to 1.0,
   *                    inclusive)
   *
   * Various driver phenomena make the life of joystick peripherals difficult:
   *
   *    * pressure-sensitive buttons reported as axes
   *    * hats reported as buttons or axes
   *    * triggers reported as:
   *        * buttons
   *        * unidirectional axis (state from 0.0 to 1.0)
   *        * combined into single axis (sum of states from -1.0 to 0.0 and 0.0 to 1.0)
   *    * inconsistent sign of analog stick axes
   *
   * Joystick operations allow the frontend to:
   *
   *    * query the virtual and physical layout of joysticks
   *    * map virtual elements to physical ones
   *    * get the events generated by virtual and physical elements
   *
   * @note #define PERIPHERAL_ADDON_JOYSTICKS before including xbmc_peripheral_dll.h
   * in the add-on if the add-on provides joysticks and add provides_joysticks="true"
   * to the xbmc.peripheral extension point node in addon.xml.
   */
  ///{
#ifdef PERIPHERAL_ADDON_JOYSTICKS
  PERIPHERAL_ERROR GetJoystickInfo(unsigned int index, JOYSTICK_INFO* info);
  void             FreeJoysticKInfo(JOYSTICK_INFO* info);

  /*!
   * @brief Assign a button index to a button ID and label
   */
  PERIPHERAL_ERROR GetButtonMap(JOYSTICK_BUTTON_MAP* button_map);
  PERIPHERAL_ERROR FreeButtonMap(JOYSTICK_BUTTON_MAP* button_map);
  PERIPHERAL_ERROR UpdateButtonMap(JOYSTICK_BUTTON_MAP_PAIR* key_value_pair);

  /*!
   * @brief Get all events that have occurred since the last call to GetEvents()
   * @return PERIPHERAL_NO_ERROR if successful; events must be freed using
   * FreeEvents() in this case
   */
  PERIPHERAL_ERROR GetEvents(JOYSTICK_EVENT_VECTOR* events);
  void FreeEvents(JOYSTICK_EVENT_VECTOR* events);
#endif
  ///}

  /*!
   * Called by the frontend to assign the function pointers of this add-on to
   * pClient. Note that get_addon() is defined here, so it will be available in
   * all compiled peripheral add-ons.
   */
  void __declspec(dllexport) get_addon(struct PeripheralAddon* pClient)
  {
    pClient->GetPeripheralAPIVersion        = GetPeripheralAPIVersion;
    pClient->GetMinimumPeripheralAPIVersion = GetMinimumPeripheralAPIVersion;
    pClient->GetAddonCapabilities           = GetAddonCapabilities;
    pClient->PerformDeviceScan              = PerformDeviceScan;
    pClient->FreeScanResults                = FreeScanResults;

#ifdef PERIPHERAL_ADDON_JOYSTICKS
    pClient->GetJoystickInfo                = GetJoystickInfo;
    pClient->FreeJoystickInfo               = FreeJoystickInfo;
    //pClient->RegisterButton                 = RegisterButton;
    pClient->GetEvents                      = GetEvents;
    pClient->FreeEvents                     = FreeEvents;
#endif
  };

#ifdef __cplusplus
};
#endif

#endif // __PERIPHERAL_DLL_H__
